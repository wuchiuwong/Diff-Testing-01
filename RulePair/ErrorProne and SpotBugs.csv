ErrorProne_RuleId,SpotBugs_RuleId,ErrorProne_RuleDescription,SpotBugs_RuleDescription
ArrayToString,DMI_INVOKING_TOSTRING_ON_ARRAY,"ArrayToString
Calling toString on an array does not provide useful information.  The toString method on an array will print its identity, such as[I@4488aabb. This is almost never needed. Use Arrays.toString to print ahuman-readable summary. Suppress false positives by adding the suppression annotation @SuppressWarnings(""ArrayToString"") to the enclosing element.","USELESS_STRING: Invocation of toString on an array
The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12."
ClassCanBeStatic,SIC_INNER_SHOULD_BE_STATIC,"ClassCanBeStatic
Inner class is non-static but does not reference enclosing class.  An inner class should be static unless it references members of its enclosingclass. An inner class that is made non-static unnecessarily uses more memory anddoes not make the intent of the class clear. Suppress false positives by adding the suppression annotation @SuppressWarnings(""ClassCanBeStatic"") to the enclosing element. ClassCanBeStaticPositiveCase1.java ClassCanBeStaticPositiveCase2.java ClassCanBeStaticPositiveCase3.java","SIC: Should be a static inner class
This class is an inner class, but does not use its embedded reference to the object which created it.  This reference makes the instances of the class larger, and may keep the reference to the creator object alive longer than necessary.  If possible, the class should be made static."
MissingCasesInEnumSwitch,SF_SWITCH_NO_DEFAULT,"MissingCasesInEnumSwitch
Switches on enum types should either handle all values, or have a default case.  Consider a switch statement that doesn’t handle all possible values and doesn’thave a default: The author’s intent isn’t clear. There are three possibilities: The default case is known to be impossible. This could be made clear byadding: \default: throw new AssertionError(color); The code intentionally ‘falls out’ of the switch on the default case, andexecution continues below. This could be made clear by adding: \default: // fall out The code has a bug, and the missing cases should have been handled. To avoid this ambiguity, the Google Java Style Guide requires eachswitch statement on an enum type to either handle all values of the enum, orhave a default statement group. Suppress false positives by adding the suppression annotation @SuppressWarnings(""MissingCasesInEnumSwitch"") to the enclosing element.","SF: Switch statement found where default case is missing
This method contains a switch statement where default case is missing. Usually you need to provide a default case."
LogicalAssignment,QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT,"LogicalAssignment
Assignment where a boolean expression was expected; use == if this assignment wasn't expected or add parentheses for clarity.  When an assignment expression is used as the condition of a loop, it isn’t clearto the reader whether the assignment was deliberate or it was intended to be anequality test. Parenthesis should be used around assignments in loop conditionsto make it clear to the reader that the assignment is deliberate. That is, instead of this: Prefer while ((x = checkSomething())) { or while (x == checkSomething()) {. Suppress false positives by adding the suppression annotation @SuppressWarnings(""LogicalAssignment"") to the enclosing element.","QBA: Method assigns boolean literal in boolean expression
This method assigns a literal boolean value (true or false) to a boolean variable inside an if or while expression. Most probably this was supposed to be a boolean comparison using ==, not an assignment using =."
FallThrough,SF_SWITCH_FALLTHROUGH,"FallThrough
Switch case may fall through.  Alternate names: fallthrough The Google Java Style Guide §4.8.4.2 requires that within a switchblock, each statement group either terminates abruptly (with a break,continue, return or throw statement), or is marked with a comment toindicate that execution will or might continue into the next statement group.This special comment is not required in the last statement group of the switchblock. Example: Suppress false positives by adding the suppression annotation @SuppressWarnings(""FallThrough"") to the enclosing element.","SF: Switch statement found where one case falls through to the next case
This method contains a switch statement where one case branch will fall through to the next case. Usually you need to end this case with a break or return."
BadInstanceof,SIO_SUPERFLUOUS_INSTANCEOF,"BadInstanceof
instanceof used in a way that is equivalent to a null check.  Flags instanceof checks where the expression can be determined to be asupertype of the type it is compared to. JLS 15.28specifically calls instanceof out as not being a compile-time constantexpression, so the usage of this pattern can lead to unreachable code that won’tbe flagged by the compiler: In general, an instanceof comparison against a superclass is equivalent to anull check: Suppress false positives by adding the suppression annotation @SuppressWarnings(""BadInstanceof"") to the enclosing element.","SIO: Unnecessary type check done using instanceof operator
Type check performed using the instanceof operator where it can be statically determined whether the object is of the type requested."
IntLongMath,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,"IntLongMath
Expression of type int may overflow before being assigned to a long.  Performing an arithmetic expression on arguments of type int and then assigningthe result to a long is error-prone. The result is widened to a long as thefinal step, and the intermediate results may overflow. For example, the following expression exceeds Integer.MAX_VALUE and overflowsto -1857093632: The corrected code (which has a value of 86400000000000) is: Suppress false positives by adding the suppression annotation @SuppressWarnings(""IntLongMath"") to the enclosing element.","ICAST: Result of integer multiplication cast to long
This code performs integer multiply and then converts the result to a long, as in:"
ArrayEquals,EC_BAD_ARRAY_COMPARE,"ArrayEquals
Reference equality used to compare arrays.  Generally when comparing arrays for equality, the programmer intends to checkthat the the contents of the arrays are equal rather than that they are actuallythe same object. But many commonly used equals methods compare arrays forreference equality rather than content equality. These include the instance.equals() method, Guava’s com.google.common.base.Objects#equal(), JDK’sjava.util.Objects#equals(), and Android’sandroid.support.v4.util.ObjectsCompat#equals. If reference equality is needed, == should be used instead for clarity.Otherwise, use java.util.Arrays#equals() to compare the contents of the arrays. Suppress false positives by adding the suppression annotation @SuppressWarnings(""ArrayEquals"") to the enclosing element. ArrayEqualsPositiveCases2.java ArrayEqualsNegativeCases2.java","EC: Invocation of equals() on an array, which is equivalent to ==
This method invokes the .equals(Object o) method on an array. Since arrays do not override the equals method of Object, calling equals on an array is the same as comparing their addresses. To compare the contents of the arrays, use java.util.Arrays.equals(Object[], Object[]). To compare the addresses of the arrays, it would be less confusing to explicitly check pointer equality using ==."
SubstringOfZero,DMI_USELESS_SUBSTRING,"SubstringOfZero
String.substring(0) returns the original String.  String.substring(int) gives you the substring from the index to the end, inclusive.Calling that method with an index of 0 will return the same String. Suppress false positives by adding the suppression annotation @SuppressWarnings(""SubstringOfZero"") to the enclosing element.","DMI: Invocation of substring(0), which returns the original value
This code invokes substring(0) on a String, which returns the original value."
ArrayHashCode,DMI_INVOKING_HASHCODE_ON_ARRAY,"ArrayHashCode
hashcode method on array does not hash array contents.  Computing a hashcode for an array is tricky. Typically you want a hashcode thatdepends on the value of each element in the array, but many of the common waysto do this actually return a hashcode based on the identity of the arrayrather than its contents. This check flags attempts to compute a hashcode from an array that do not takethe contents of the array into account. There are several ways to mess this up: Call the instance .hashCode() method on an array. Call the JDK method java.util.Objects#hashCode() with an argument of arraytype. Call the JDK method java.util.Objects#hash() or the Guava methodcom.google.common.base.Objects#hashCode() with multiple arguments, atleast one of which is an array. Call the JDK method java.util.Objects#hash() or the Guava methodcom.google.common.base.Objects#hashCode() with a single argument ofprimitive array type. Because these are varags methods that takeObject..., the primitive array is autoboxed into a single-element Objectarray, and these methods use the identity hashcode of the primitive arrayrather than examining its contents. Note that calling these methods on anargument of Object array type actually does the right thing because noboxing is needed. Please use either java.util.Arrays#hashCode() (for single-dimensional arrays)or java.util.Arrays#deepHashCode() (for multidimensional arrays) to compute ahash value that depends on the contents of the array. If you really intended tocompute the identity hash code, consider usingjava.lang.System#identityHashCode() instead for clarity. Suppress false positives by adding the suppression annotation @SuppressWarnings(""ArrayHashCode"") to the enclosing element.","DMI: Invocation of hashCode on an array
The code invokes hashCode on an array. Calling hashCode on an array returns the same value as System.identityHashCode, and ignores the contents and length of the array. If you need a hashCode that depends on the contents of an array a, use java.util.Arrays.hashCode(a)."
ToStringReturnsNull,NP_TOSTRING_COULD_RETURN_NULL,"ToStringReturnsNull
An implementation of Object.toString() should never return null.  Suppress false positives by adding the suppression annotation @SuppressWarnings(""ToStringReturnsNull"") to the enclosing element.","NP: toString method may return null
This toString method seems to return null in some circumstances. A liberal reading of the spec could be interpreted as allowing this, but it is probably a bad idea and could cause other code to break. Return the empty string or some other appropriate string rather than null."
EqualsHashCode,HE_EQUALS_USE_HASHCODE,"EqualsHashCode
Classes that override equals should also override hashCode.  The contract for Object.hashCode states that if two objects are equal, thencalling the hashCode() method on each of the two objects must produce the sameresult. Implementing equals() but not hashCode() causes broken behaviourwhen trying to store the object in a collection. See Effective Java 3rd Edition §11 for more information and a discussion of howto correctly implement hashCode(). Suppress false positives by adding the suppression annotation @SuppressWarnings(""EqualsHashCode"") to the enclosing element.","HE: Class defines equals() and uses Object.hashCode()
This class overrides equals(Object), but does not override hashCode(), and inherits the implementation of hashCode() from java.lang.Object (which returns the identity hash code, an arbitrary value assigned to the object by the VM).  Therefore, the class is very likely to violate the invariant that equal objects must have equal hashcodes."
MathRoundIntLong,ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND,"MathRoundIntLong
Math.round(Integer) results in truncation.  Math.round() called with an integer or long type results in truncation because Math.round only accepts floats or doubles and some integers and longs can’t be represented with float. Suppress false positives by adding the suppression annotation @SuppressWarnings(""MathRoundIntLong"") to the enclosing element.","ICAST: int value cast to float and then passed to Math.round
This code converts an int value to a float precision floating point number and then passing the result to the Math.round() function, which returns the int/long closest to the argument. This operation should always be a no-op, since the converting an integer to a float should give a number with no fractional part. It is likely that the operation that generated the value to be passed to Math.round was intended to be performed using floating point arithmetic."
ReturnValueIgnored,RV_RETURN_VALUE_IGNORED,"ReturnValueIgnored
Return value of this method must be used.  Alternate names: ResultOfMethodCallIgnored, CheckReturnValue Certain library methods do nothing useful if their return value is ignored. Forexample, String.trim() has no side effects, and you must store the return valueof String.intern() to access the interned string. This check encodes a list ofmethods in the JDK whose return value must be used and issues an error if theyare not. Suppress false positives by adding the suppression annotation @SuppressWarnings(""ReturnValueIgnored"") to the enclosing element.","RV: Method ignores return value
The return value of this method should be checked. One common cause of this warning is to invoke a method on an immutable object, thinking that it updates the object. For example, in the following code fragment,"
ArraysAsListPrimitiveArray,VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG,"ArraysAsListPrimitiveArray
Arrays.asList does not autobox primitive arrays, as one might expect.  Arrays.asList does not autobox primitive arrays, as one might expect. If youintended to autobox the primitive array, use an asList method from Guava thatdoes autobox. If you intended to create a singleton list containing theprimitive array, use Collections.singletonList to make your intent clearer. Suppress false positives by adding the suppression annotation @SuppressWarnings(""ArraysAsListPrimitiveArray"") to the enclosing element.","VA: Primitive array passed to function expecting a variable number of object arguments
This code passes a primitive array to a function that takes a variable number of object arguments. This creates an array of length one to hold the primitive array and passes it to the function."
InfiniteRecursion,IL_INFINITE_RECURSIVE_LOOP,"InfiniteRecursion
This method always recurses, and will cause a StackOverflowError.  A method that always calls itself will cause a StackOverflowError. The fix may be to call another method with the same name: or to call the method on a different instance: Suppress false positives by adding the suppression annotation @SuppressWarnings(""InfiniteRecursion"") to the enclosing element.","IL: An apparent infinite recursive loop
This method unconditionally invokes itself. This would seem to indicate an infinite recursive loop that will result in a stack overflow."
EqualsIncompatibleType,EC_UNRELATED_TYPES,"EqualsIncompatibleType
An equality test between objects with incompatible types always returns false.  Consider the following code: We understand that any Integer will not be equal to any String. However,the signature of the equals method accepts any Object, so the compiler willhappily allow us to pass an Integer to the equals method. However, it willalways return false, which is probably not what we intended. This check detects circumstances where the equals method is called when the twoobjects in question can never be equal to each other. We check the followingequality methods: Good! Many tests of equals methods neglect to test that equals on an unrelatedobject return false. We recommend using Guava’s EqualsTester to perform tests of yourequals method. Simply give it a collection of objects of your class, broken intogroups that should be equal to each other, and EqualsTester will ensure that: Which should exhaustively check all of the properties of equals andhashCode. The javadoc of Object.equals(Object) defines object equality veryprecisely: The equals method implements an equivalence relation on non-null objectreferences: It is reflexive: for any non-null reference value x, x.equals(x) should returntrue. It is symmetric: for any non-null reference values x and y, x.equals(y) shouldreturn true if and only if y.equals(x) returns true. It is transitive: for any non-null reference values x, y, and z, ifx.equals(y) returns true and y.equals(z) returns true, then x.equals(z) shouldreturn true. It is consistent: for any non-null reference values x and y, multipleinvocations of x.equals(y) consistently return true or consistently returnfalse, provided no information used in equals comparisons on the objects ismodified. For any non-null reference value x, x.equals(null) should return false. TIP: EqualsTester validates each of these properties. For most simple value objects (e.g.: a Point containing x and ycoordinates), this generally means that the equals method will only return trueif the other object has the exact same class, and each of the components isequal to the corresponding component in the other object. Here, there arenumerous tools in the Java ecosystem to generate the appropriate equals andhashCode method implementations, including AutoValue. Another pattern often seen is to declare a common supertype with a definedequals method (like List, which defines equality by having equal elements inthe same order). Then, different subclasses of that supertype (LinkedList andArrayList) can be equal to other classes with that supertype, since theconcrete class of the List is irrelevant. This checker will allow these typesof equality, as we detect when two objects share a common supertype with anequals implementation and allow that to succeed. Outside of these two general groups of equals methods, however, it’s verydifficult to produce correctly-behaving equals methods. Most of the time, whenequals is implemented in a non-obvious manner, one or more of the propertiesabove isn’t satisfied (generally the symmetric property). This can result insubtle bugs, explained below. Here, Foo’s equals method is defined to accept a String value in addition toother Foo’s. This may appear to work at first, but you end up with somecomplex situations: Suppress false positives by adding the suppression annotation @SuppressWarnings(""EqualsIncompatibleType"") to the enclosing element.","EC: Call to equals() comparing different types
This method calls equals(Object) on two references of different class types and analysis suggests they will be to objects of different classes at runtime. Further, examination of the equals methods that would be invoked suggest that either this call will always return false, or else the equals method is not be symmetric (which is a property required by the contract for equals in class Object)."
BigDecimalLiteralDouble,DMI_BIGDECIMAL_CONSTRUCTED_FROM_DOUBLE,"BigDecimalLiteralDouble
new BigDecimal(double) loses precision in this case.  BigDecimal’s double can lose precision in surprising ways. java {bad}  // these are the same:  new BigDecimal(0.1)  new BigDecimal(""0.1000000000000000055511151231257827021181583404541015625"") Prefer the BigDecimal.valueOf(double) method or the new BigDecimal(String)constructor. NOTE BigDecimal.valueOf(double) does not suffer from the same problem; it isequivalent to new BigDecimal(Double.valueOf(double)), and while 0.1 is notexactly representable, Double.valueOf(0.1) yields ""0.1"". As long asFloatingPointLiteralPrecision doesn’tgenerate a warning, BigDecimal.valueOf is safe. Suppress false positives by adding the suppression annotation @SuppressWarnings(""BigDecimalLiteralDouble"") to the enclosing element.","DMI: BigDecimal constructed from double that isn’t represented precisely
This code creates a BigDecimal from a double value that doesn't translate well to a decimal number. For example, one might assume that writing new BigDecimal(0.1) in Java creates a BigDecimal which is exactly equal to 0.1 (an unscaled value of 1, with a scale of 1), but it is actually equal to 0.1000000000000000055511151231257827021181583404541015625. You probably want to use the BigDecimal.valueOf(double d) method, which uses the String representation of the double to create the BigDecimal (e.g., BigDecimal.valueOf(0.1) gives 0.1)."
RandomCast,RV_01_TO_INT,"RandomCast
Casting a random number in the range [0.0, 1.0) to an integer or long always results in 0.  Math.random(), Random#nextFloat, and Random#nextDouble return results inthe range [0.0, 1.0). Therefore, casting the result to (int) or (long)always results in the value of 0. Suppress false positives by adding the suppression annotation @SuppressWarnings(""RandomCast"") to the enclosing element.","RV: Random value from 0 to 1 is coerced to the integer 0
A random value from 0 to 1 is being coerced to the integer value 0. You probably want to multiply the random value by something else before coercing it to an integer, or use the Random.nextInt(n) method."
CollectionIncompatibleType,GC_UNRELATED_TYPES,"CollectionIncompatibleType
Incompatible type as argument to Object-accepting Java collections method.  Querying a collection for an element it cannot possibly contain is almostcertainly a bug. In a generic collection type, query methods such as Map.get(Object) andCollection.remove(Object) accept a parameter that identifies a potentialelement to look for in that collection. This check reports cases where thiselement cannot be present because its type and the collection’s genericelement type are “incompatible.” A typical example: This code looks reasonable, but there’s a problem: The Set contains Longinstances, but the argument to contains is an Integer. Because no instancecan be of type Integer and of type Long at the same time, the containscheck always fails. This is clearly not what the developer intended. Why does the collection API permit this kind of mistake? Why not declare themethod as contains(E)? After all, that is what the collections API does formethods that store an element in the collection: They require that passed typebe strictly assignable to the collection’s element type. For example: The code above rightly won’t compile, because numbers might be a (forexample) Set<Long>, and adding an Integer value would corrupt it. But this restriction is necessary only for methods that insert elements. Methodsthat only query or remove elements cannot corrupt the collection: In this case, the Integer 42 might be contained in numbers, and should beremoved if it is, but if numbers is a Set<Long>, no harm is done. We’d like to define contains in a way that rejects the bad call but permitsthe good one. But Java’s type system is not powerful enough. Our solution isstatic analysis. The specific restriction we would like to express for the two types is notassignability, but “compatibility”. Informally, we mean that it must at least bepossible for some instance to be of both types. Formally, we require that a“casting conversion” exist between the types as defined byJLS 5.5.1. The result is that the method can be defined as contains(Object), permittingthe “good” call above, but that Error Prone will give errors for incompatiblearguments, preventing the “bad.” We might say: Sure, a buggy remove call can’t corrupt a collection. And sure,someone might want to pass an Object reference that happens to contain an E.But isn’t that a low standard for an API? We don’t normally write code that way: Such code would invite bugs. To avoid that, we require a Throwable. Users whohave an Object reference that might be a Throwable can test instanceof andcast. So why not require the same thing in the collections API? Of course, we can’t really change the API of Collection. But if we weredesigning a similar API, what would we do – require E or accept any Object? The burden of proof falls on accepting Object, since doing so permits buggycode. And we’re not going to settle for “it occasionally saves users a cast.” The main reason to accept Object is to permit a fast, type-safe Set.equalsimplementation. (equals is actually just one example of the general problem, which arises withmany uses of wildcards. Once you’ve read the following, consider the problem ofimplementing Collection.removeAll(Collection<?>) without contains(Object).Then consider how the problem would exist even if the signature wereremoveAll(Collection<? extends E>). The removeAll problem is at least“solvable” by changing the signature to removeAll(Collection<E>), but thatsignature may reject useful calls.) Here’s how: equals necessarily accepts a plain Object. It can test whetherthat Object is a Set, but it can’t know the element type it was originallydeclared with. In short, equals has to operate on a Set<?>. If contains were to require an E, equals would be in trouble because itdoesn’t know what E is. In particular, it wouldn’t be able to callotherSet.contains(myElement) for any of its elements. It would have only two options: It could copy the entire other Set into aSet<Object>, or it could perform an unchecked cast. Copying is wasteful, so inpractice, equals would need an unchecked cast. This is probably acceptable,but we might feel strange for defining an API that can be implemented only byperforming unchecked casts. Does a cleaner implementation (and occasional convenience to callers) outweighthe bugs that accepting Object enables? That’s a tough question. The good newsis that this Error Prone check gives you some of the best of both worlds. It is technically possible for a Set<Integer> to contain a String element,but only if an unchecked warning was earlier ignored or improperly suppressed.Such practice should never be treated as acceptable, so it makes no practicaldifference to our arguments above. Suppress false positives by adding the suppression annotation @SuppressWarnings(""CollectionIncompatibleType"") to the enclosing element.","GC: No relationship between generic parameter and method argument
This call to a generic collection method contains an argument with an incompatible class from that of the collection's parameter (i.e., the type of the argument is neither a supertype nor a subtype of the corresponding generic type argument). Therefore, it is unlikely that the collection contains any objects that are equal to the method argument used here. Most likely, the wrong value is being passed to the method."
DeadException,RV_EXCEPTION_NOT_THROWN,"DeadException
Exception created but not thrown.  Alternate names: ThrowableInstanceNeverThrown The exception is created with new, but is not thrown, and the reference islost. Creating an exception without using it is unlikely to be correct, so we assumethat you wanted to throw the exception. Suppress false positives by adding the suppression annotation @SuppressWarnings(""DeadException"") to the enclosing element.","RV: Exception created and dropped rather than thrown
This code creates an exception (or error) object, but doesn't do anything with it. For example, something like"
DefaultCharset,DM_DEFAULT_ENCODING,"DefaultCharset
Implicit use of the platform default charset, which can result in differing behaviour between JVM executions or incorrect behavior if the encoding of the data source doesn't match expectations.  A Charset is a mapping between sequences of16-bit Unicode code units and sequences of bytes. Charsets are usedwhen encoding characters into bytes and decoding bytes into characters. Using APIs that rely on the JVM’s default Charset under the hood is dangerous.The default charset can vary from machine to machine or JVM to JVM. This canlead to unstable character encoding/decoding between runs of your program, evenfor ASCII characters (e.g.: A is 0100 0001 in UTF-8, but is 0000 00000100 0001 in UTF-16). If you need stable encoding/decoding, you must specify an explicit charset. TheStandardCharsets class provides these constants for you. When in doubt, use UTF-8. Suppress false positives by adding the suppression annotation @SuppressWarnings(""DefaultCharset"") to the enclosing element.","Dm: Reliance on default encoding
Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly."
EqualsUnsafeCast,BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS,"EqualsUnsafeCast
The contract of #equals states that it should return false for incompatible types, while this implementation may throw ClassCastException.  Implementations of #equals should return false for different types, notthrow. Suppress false positives by adding the suppression annotation @SuppressWarnings(""EqualsUnsafeCast"") to the enclosing element.","BC: Equals method should not assume anything about the type of its argument
The equals(Object o) method shouldn't make any assumptions about the type of o. It should simply return false if o is not the same type as this."
BadShiftAmount,ICAST_BAD_SHIFT_AMOUNT,"BadShiftAmount
Shift by an amount that is out of range.  For shift operations on int types, only the five lowest-order bits of the shiftamount are used as the shift distance. This means that shift amounts that arenot in the range 0 to 31, inclusive, are silently mapped to values in thatrange. For example, a shift of an int by 32 is equivalent to shifting by 0,i.e., a no-op. See JLS 15.19, “Shift Operators”, for more details. Suppress false positives by adding the suppression annotation @SuppressWarnings(""BadShiftAmount"") to the enclosing element.","BSHIFT: 32 bit int shifted by an amount not in the range -31..31
The code performs shift of a 32 bit int by a constant amount outside the range -31..31. The effect of this is to use the lower 5 bits of the integer value to decide how much to shift by (e.g., shifting by 40 bits is the same as shifting by 8 bits, and shifting by 32 bits is the same as shifting by zero bits). This probably isn't what was expected, and it is at least confusing."
EqualsNaN,FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER,"EqualsNaN
== NaN always returns false; use the isNaN methods instead.  As per JLS 15.21.1, == NaN comparisons always return false, even NaN == NaN.Instead, use the isNaN methods to check for NaN. Suppress false positives by adding the suppression annotation @SuppressWarnings(""EqualsNaN"") to the enclosing element.","FE: Doomed test for equality to NaN
This code checks to see if a floating point value is equal to the special Not A Number value (e.g., if (x == Double.NaN)). However, because of the special semantics of NaN, no value is equal to Nan, including NaN. Thus, x == Double.NaN always evaluates to false.  To check to see if a value contained in x is the special Not A Number value, use Double.isNaN(x) (or Float.isNaN(x) if x is floating point precision)."
MathAbsoluteRandom,RV_ABSOLUTE_VALUE_OF_RANDOM_INT,"MathAbsoluteRandom
Math.abs does not always give a positive result. Please consider other methods for positive random numbers.  Math.absreturns a negative number when called with the largest negative number. Example: When trying to generate positive random numbers by using Math.abs around arandom positive-or-negative integer (or long), there will a rare edge case wherethe returned value will be negative. This is because there is no positive integer with the same magnitude asInteger.MIN_VALUE, which is equal to -Integer.MAX_VALUE - 1. Floating pointnumbers don’t suffer from this problem, as the sign is stored in a separate bit. Instead, one should use random number generation functions that are guaranteedto generate positive numbers: or map negative numbers onto the non-negative range: Suppress false positives by adding the suppression annotation @SuppressWarnings(""MathAbsoluteRandom"") to the enclosing element.","RV: Bad attempt to compute absolute value of signed random integer
This code generates a random signed integer and then computes the absolute value of that random integer.  If the number returned by the random number generator is Integer.MIN_VALUE, then the result will be negative as well (since Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE). (Same problem arises for long values as well)."
DoubleCheckedLocking,DC_DOUBLECHECK,"DoubleCheckedLocking
Double-checked locking on non-volatile fields is unsafe.  Using double-checked locking on mutable objects in non-volatile fields is notthread-safe. If the field is not volatile, the compiler may re-order the code in theaccessor. For more information, see: The canonical example of correct double-checked locking for lazyinitialization is: Double-checked locking should only be used in performance critical classes. Forcode that is less performance sensitive, there are simpler, more readableapproaches. Effective Java recommends two alternatives: For lazily initializing instance fields, consider a synchronized accessor. Inmodern JVMs with efficient uncontended synchronization the performancedifference is often negligible. If the field being initialized is static, consider using the lazyinitialization holder class idiom: If the object being initialized with double-checked locking isimmutable,then it is safe for the field to be non-volatile. However, the use of volatileis still encouraged because it is almost free on x86 and makes the code moreobviously correct. Note that immutable has a very specific meaning in this context: [An immutable object] is transitively reachable from a final field, has notchanged since the final field was set, and a reference to the objectcontaining the final field did not escape the constructor. Double-checked locking on non-volatile fields is in general unsafe because thecompiler and JVM can re-order code from the object’s constructor to occurafter the object is written to the field. The final modifier prevents that re-ordering from occurring, and guarantees thatall of the object’s final fields have been written to before a reference to thatobject is published. Suppress false positives by adding the suppression annotation @SuppressWarnings(""DoubleCheckedLocking"") to the enclosing element.","DC: Possible double check of field
This method may contain an instance of double-checked locking. This idiom is not correct according to the semantics of the Java memory model.  For more information, see the web page http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html."
BadInstanceof,BC_VACUOUS_INSTANCEOF,"BadInstanceof
instanceof used in a way that is equivalent to a null check.  Flags instanceof checks where the expression can be determined to be asupertype of the type it is compared to. JLS 15.28specifically calls instanceof out as not being a compile-time constantexpression, so the usage of this pattern can lead to unreachable code that won’tbe flagged by the compiler: In general, an instanceof comparison against a superclass is equivalent to anull check: Suppress false positives by adding the suppression annotation @SuppressWarnings(""BadInstanceof"") to the enclosing element.","BC: instanceof will always return true
This instanceof test will always return true (unless the value being tested is null). Although this is safe, make sure it isn't an indication of some misunderstanding or some other logic error. If you really want to test the value for being null, perhaps it would be clearer to do better to do a null test rather than an instanceof test."
InstanceOfAndCastMatchWrongType,BC_IMPOSSIBLE_CAST,"InstanceOfAndCastMatchWrongType
Casting inside an if block should be plausibly consistent with the instanceof type.  Suppress false positives by adding the suppression annotation @SuppressWarnings(""InstanceOfAndCastMatchWrongType"") to the enclosing element.","BC: Impossible cast
This cast will always throw a ClassCastException. SpotBugs tracks type information from instanceof checks, and also uses more precise information about the types of values returned from methods and loaded from fields. Thus, it may have more precise information that just the declared type of a variable, and can use this to determine that a cast will always throw an exception at runtime."
NonAtomicVolatileUpdate,VO_VOLATILE_INCREMENT,"NonAtomicVolatileUpdate
This update of a volatile variable is non-atomic.  The volatile modifier ensures that updates to a variable are propagatedpredictably to other threads. A read of a volatile variable always returns themost recent write by any thread. However, this does not mean that all updates to a volatile variable are atomic.For example, if you increment or decrement a volatile variable, you are actuallydoing (1) a read of the variable, (2) an increment or decrement of a local copy,and (3) a write back to the variable. Each step is atomic individually, but thewhole sequence is not, and it will cause a race condition if two threads try toincrement or decrement a volatile variable at the same time. The same is truefor compound assignment, e.g. foo += bar. If you intended for this update to be atomic, you should wrap all updateoperations on this variable in a synchronized block. If the variable is aninteger, you could use an AtomicInteger instead of a volatile int. Suppress false positives by adding the suppression annotation @SuppressWarnings(""NonAtomicVolatileUpdate"") to the enclosing element.","VO: An increment to a volatile field isn’t atomic
This code increments a volatile field. Increments of volatile fields aren't atomic. If more than one thread is incrementing the field at the same time, increments could be lost."
